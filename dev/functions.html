<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · SmallCouplingDynamicCavity.jl Documentation</title><meta name="title" content="Functions · SmallCouplingDynamicCavity.jl Documentation"/><meta property="og:title" content="Functions · SmallCouplingDynamicCavity.jl Documentation"/><meta property="twitter:title" content="Functions · SmallCouplingDynamicCavity.jl Documentation"/><meta name="description" content="Documentation for SmallCouplingDynamicCavity.jl Documentation."/><meta property="og:description" content="Documentation for SmallCouplingDynamicCavity.jl Documentation."/><meta property="twitter:description" content="Documentation for SmallCouplingDynamicCavity.jl Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">SmallCouplingDynamicCavity.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="guide.html">Guide</a></li><li class="is-active"><a class="tocitem" href="functions.html">Functions</a><ul class="internal"><li><a class="tocitem" href="#Module-Index"><span>Module Index</span></a></li><li><a class="tocitem" href="#Detailed-API"><span>Detailed API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="functions.html">Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="functions.html">Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/main/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-MyAwesomePackage-Module"><a class="docs-heading-anchor" href="#The-MyAwesomePackage-Module">The MyAwesomePackage Module</a><a id="The-MyAwesomePackage-Module-1"></a><a class="docs-heading-anchor-permalink" href="#The-MyAwesomePackage-Module" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.SmallCouplingDynamicCavity" href="#SmallCouplingDynamicCavity.SmallCouplingDynamicCavity"><code>SmallCouplingDynamicCavity.SmallCouplingDynamicCavity</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Module for &quot;SmallCouplingDynamicCavity.jl&quot; – A package for a Small Coupling expansion of the Dynamic Cavity method for epidemic inference.</p><p><strong>Exports</strong></p><ul><li><a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel"><code>EpidemicModel</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.ROC_curve-Union{Tuple{TI}, Tuple{Vector{Float64}, Vector{TI}}} where TI&lt;:Integer"><code>ROC_curve</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SI"><code>SI</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SIR"><code>SIR</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SIRS"><code>SIRS</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SIS"><code>SIS</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.bethe_lattice-Tuple{Int64, Int64}"><code>bethe_lattice</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}"><code>run_SCDC</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.run_SCDC!-Union{Tuple{TG}, Tuple{TI}, Tuple{Array{SmallCouplingDynamicCavity.Node{TI, TG}, 1}, EpidemicModel{TI, TG}, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}"><code>run_SCDC!</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SI, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>sim_epidemics</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/SmallCouplingDynamicCavity.jl#L1-L8">source</a></section></article><h2 id="Module-Index"><a class="docs-heading-anchor" href="#Module-Index">Module Index</a><a id="Module-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Index" title="Permalink"></a></h2><ul><li><a href="functions.html#SmallCouplingDynamicCavity.SmallCouplingDynamicCavity"><code>SmallCouplingDynamicCavity.SmallCouplingDynamicCavity</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}, Matrix{Int8}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:Graphs.AbstractGraph}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}, Matrix{Int8}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Vector{&lt;:Graphs.AbstractGraph})}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:Graphs.AbstractGraph}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Vector{&lt;:Graphs.AbstractGraph})}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.Marginal"><code>SmallCouplingDynamicCavity.Marginal</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.Message"><code>SmallCouplingDynamicCavity.Message</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.Node"><code>SmallCouplingDynamicCavity.Node</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SI"><code>SmallCouplingDynamicCavity.SI</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SIR"><code>SmallCouplingDynamicCavity.SIR</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SIRS"><code>SmallCouplingDynamicCavity.SIRS</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.SIS"><code>SmallCouplingDynamicCavity.SIS</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.ROC_curve-Union{Tuple{TI}, Tuple{Vector{Float64}, Vector{TI}}} where TI&lt;:Integer"><code>SmallCouplingDynamicCavity.ROC_curve</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.bethe_lattice-Tuple{Int64, Int64}"><code>SmallCouplingDynamicCavity.bethe_lattice</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Vector{Int64}, Float64, Vector{Float64}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.run_SCDC!-Union{Tuple{TG}, Tuple{TI}, Tuple{Array{SmallCouplingDynamicCavity.Node{TI, TG}, 1}, EpidemicModel{TI, TG}, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC!</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.run_SCDC!-Union{Tuple{TG}, Tuple{TI}, Tuple{Array{SmallCouplingDynamicCavity.Node{TI, TG}, 1}, EpidemicModel{TI, TG}, Float64, Vector{Int64}, Float64, Vector{Float64}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC!</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SI, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIR, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIS, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a></li><li><a href="functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIRS, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a></li></ul><h2 id="Detailed-API"><a class="docs-heading-anchor" href="#Detailed-API">Detailed API</a><a id="Detailed-API-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.EpidemicModel" href="#SmallCouplingDynamicCavity.EpidemicModel"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EpidemicModel</code></pre><p>Epidemic model containing all the informations of the system.</p><p><strong>Fields</strong></p><ul><li><p><code>Disease::SmallCouplingDynamicCavity.InfectionModel</code>: Infection model. Currently are implemented SI, SIR, SIS and SIRS infection models.</p></li><li><p><code>G::Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Graphs.AbstractGraph</code>: Contact graph. It can be either an AbstractGraph (contact graph constant over time) or a Vector of AbstractGraph (time varying contact graph).</p></li><li><p><code>N::Int64</code>: Number of nodes of the contact graph.</p></li><li><p><code>T::Int64</code>: Number of time steps.</p></li><li><p><code>ν::Array{Float64, 3}</code>: Infection couplings. It is a NVxNVx(T+1) Array where νᵗᵢⱼ=log(1-λᵗᵢⱼ), with λᵗᵢⱼ being the infection probability from individual i to individual j at time t.</p></li><li><p><code>obsmat::Matrix{Int8}</code>: Observations matrix. It is a NVx(T+1) Matrix, where obsᵗᵢ is the observation of individual i at time t: it is equal to -1.0 if not observed, 0.0 if S, 1.0 if I, 2.0 if R (only for SIR and SIRS).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}, Matrix{Int8}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Vector{&lt;:Graphs.AbstractGraph})}" href="#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}, Matrix{Int8}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Vector{&lt;:Graphs.AbstractGraph})}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EpidemicModel(
    infectionmodel::TI, 
    G::TG, T::Int, 
    ν::Array{Float64, 3}, 
    obs::Matrix{Int8}) where {TI&lt;:InfectionModel,TG&lt;:Vector{&lt;:AbstractGraph}}</code></pre><p>Defines the epidemic model.</p><p>This function defines an epidemic model based on the provided infection model, contact graph, time steps, infection couplings, and observation matrix.</p><pre><code class="nohighlight hljs"># Arguments
- `infectionmodel`: The infection model. Currently implemented models include SI, SIR, SIS, and SIRS infection models.
- `G`: The contact graph. It should be a T+1 vector of AbstractGraph representing the time-varying contact graph.
- `T`: The number of time-steps.
- `ν`: The infection couplings. It should be a 3-dimensional array of size NVxNVx(T+1), where νᵗᵢⱼ=log(1-λᵗᵢⱼ), with λᵗᵢⱼ being the infection probability from individual i to individual j at time t.
- `obs`: The observations obsmatrix. It should be a NVx(T+1) matrix, where obsᵗᵢ is the observation of individual i at time t: it is equal to -1.0 if not observed, 0.0 if S, 1.0 if I, 2.0 if R (only for SIR and SIRS).

# Returns
- `EpidemicModel`: An [`EpidemicModel`](@ref) object representing the defined epidemic model.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L144-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}, Matrix{Int8}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:Graphs.AbstractGraph}" href="#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}, Matrix{Int8}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:Graphs.AbstractGraph}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EpidemicModel(
    infectionmodel::TI, 
    G::TG, T::Int, 
    ν::Array{Float64, 3}, 
    obs::Matrix{Int8}) where {TI&lt;:InfectionModel,TG&lt;:AbstractGraph}</code></pre><p>Defines the epidemic model.</p><p>This function defines an epidemic model based on the provided infection model, contact graph, time steps, infection couplings, and observation matrix.</p><p><strong>Arguments</strong></p><ul><li><code>infectionmodel</code>: The infection model. Currently implemented models include SI, SIR, SIS, and SIRS infection models.</li><li><code>G</code>: The contact graph. It should be an AbstractGraph representing the contact graph, which is time-varying.</li><li><code>T</code>: The number of time-steps.</li><li><code>ν</code>: The infection couplings. It should be a 3-dimensional array of size NVxNVx(T+1), where νᵗᵢⱼ=log(1-λᵗᵢⱼ), with λᵗᵢⱼ being the infection probability from individual i to individual j at time t.</li><li><code>obs</code>: The observations matrix. It should be a NVx(T+1) matrix, where obsᵗᵢ is the observation of individual i at time t: it is equal to -1.0 if not observed, 0.0 if S, 1.0 if I, 2.0 if R (only for SIR and SIRS).</li></ul><p><strong>Returns</strong></p><ul><li><code>EpidemicModel</code>: An <a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel"><code>EpidemicModel</code></a> object representing the defined epidemic model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L115-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Vector{&lt;:Graphs.AbstractGraph})}" href="#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Vector{&lt;:Graphs.AbstractGraph})}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EpidemicModel(
    infectionmodel::TI, 
    G::TG, T::Int, 
    ν::Array{Float64, 3}) where {TI&lt;:InfectionModel,TG&lt;:Vector{&lt;:AbstractGraph}}</code></pre><p>Define an epidemic model.</p><p>This function defines an epidemic model based on the provided infection model, time-varying contact graph, time steps, and infection couplings. It initializes the observation matrix with zeros.</p><p><strong>Arguments</strong></p><ul><li><code>infectionmodel</code>: The infection model. Currently implemented models include SI, SIR, SIS, and SIRS infection models.</li><li><code>G</code>: The contact graph. It should be a T+1 vector of AbstractGraph representing the time-varying contact graph.</li><li><code>T</code>: The number of time-steps.</li><li><code>ν</code>: The infection couplings. It should be a 3-dimensional array of size NVxNVx(T+1), where νᵗᵢⱼ=log(1-λᵗᵢⱼ), with λᵗᵢⱼ being the infection probability from individual i to individual j at time t.</li></ul><p><strong>Returns</strong></p><ul><li><code>EpidemicModel</code>: An <a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel"><code>EpidemicModel</code></a> object representing the defined epidemic model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L201-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:Graphs.AbstractGraph}" href="#SmallCouplingDynamicCavity.EpidemicModel-Union{Tuple{TG}, Tuple{TI}, Tuple{TI, TG, Int64, Array{Float64, 3}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:Graphs.AbstractGraph}"><code>SmallCouplingDynamicCavity.EpidemicModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EpidemicModel(
    infectionmodel::TI, 
    G::TG, T::Int, 
    ν::Array{Float64, 3}) where {TI&lt;:InfectionModel,TG&lt;:AbstractGraph}</code></pre><p>Define an epidemic model.</p><p>This function defines an epidemic model based on the provided infection model, contact graph, time steps, and infection couplings. It initializes the observation matrix with zeros.</p><p><strong>Arguments</strong></p><ul><li><code>infectionmodel</code>: The infection model. Currently implemented models include SI, SIR, SIS, and SIRS infection models.</li><li><code>G</code>: The contact graph. It should be an AbstractGraph representing the contact graph, which is constant over time.</li><li><code>T</code>: The number of time-steps.</li><li><code>ν</code>: The infection couplings. It should be a 3-dimensional array of size NVxNVx(T+1), where νᵗᵢⱼ=log(1-λᵗᵢⱼ), with λᵗᵢⱼ being the infection probability from individual i to individual j at time t.</li></ul><p><strong>Returns</strong></p><ul><li><code>EpidemicModel</code>: An <a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel"><code>EpidemicModel</code></a> object representing the defined epidemic model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L173-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.Marginal" href="#SmallCouplingDynamicCavity.Marginal"><code>SmallCouplingDynamicCavity.Marginal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Marginal</code></pre><p>Marginals pᵢ(xᵢ) and μᵢ.</p><p><strong>Fields</strong></p><ul><li><p><code>i::Int64</code>: Index of the node i.</p></li><li><p><code>m::Matrix{Float64}</code>: (nstates)x(T+1) Matrix of marginals over time, where nstates is the number of states that the infection model has.</p></li><li><p><code>μ::Vector{Float64}</code>: T+1 Vector of marginals μᵢ over time.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L65-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.Message" href="#SmallCouplingDynamicCavity.Message"><code>SmallCouplingDynamicCavity.Message</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Message</code></pre><p>Cavity messages mᵢⱼ and μᵢⱼ.</p><p><strong>Fields</strong></p><ul><li><p><code>i::Int64</code>: Index of the node i.</p></li><li><p><code>j::Int64</code>: Index of the node j.</p></li><li><p><code>m::Vector{Float64}</code>: T+1 Vector of messages mᵢⱼ over time.</p></li><li><p><code>μ::Vector{Float64}</code>: T+1 Vector of messages μᵢⱼ over time.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L32-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.Node" href="#SmallCouplingDynamicCavity.Node"><code>SmallCouplingDynamicCavity.Node</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Node</code></pre><p>Type containing all the informations of a node. </p><p><strong>Fields</strong></p><ul><li><p><code>i::Int64</code>: Index of the node.</p></li><li><p><code>∂::Vector{Int64}</code>: List of neighbours. If the underlying contact graph is varying in time it is the union of all the neighbours over time.</p></li><li><p><code>∂_idx::Dict{Int64, Int64}</code>: Only for developers.</p></li><li><p><code>marg::SmallCouplingDynamicCavity.Marginal</code>: Marginals of the node. It is a <a href="functions.html#SmallCouplingDynamicCavity.Marginal"><code>Marginal</code></a> type.</p></li><li><p><code>cavities::Vector{SmallCouplingDynamicCavity.Message}</code>: Cavities messages entering into the node from its neigbours. It is a vector of <a href="functions.html#SmallCouplingDynamicCavity.Message"><code>Message</code></a>, each one corresponding to a neighbour with the same order of ∂.</p></li><li><p><code>νs::Vector{Vector{Float64}}</code>: Infection couplings of the neighbours against the node.</p></li><li><p><code>obs::Matrix{Float64}</code>: Observation probability matrix.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/types.jl#L230-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.ROC_curve-Union{Tuple{TI}, Tuple{Vector{Float64}, Vector{TI}}} where TI&lt;:Integer" href="#SmallCouplingDynamicCavity.ROC_curve-Union{Tuple{TI}, Tuple{Vector{Float64}, Vector{TI}}} where TI&lt;:Integer"><code>SmallCouplingDynamicCavity.ROC_curve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROC_curve(marg::Vector{Float64}, x::Vector{TI}) where {TI&lt;:Integer}</code></pre><p>Compute the Receiver Operating Characteristic (ROC) curve and the Area Under the Curve (AUC) based on inferred marginal probabilities and true configurations.</p><p>This function computes the ROC curve by sorting the marginal probabilities (<code>marg</code>) in decreasing order and sorting the true configuration (<code>x</code>) correspondingly. It then iterates over the sorted values to calculate the True Positive Rate (TPR) and False Positive Rate (FPR) at different thresholds, and computes the AUC.</p><p><strong>Arguments</strong></p><ul><li><code>marg</code>: A vector containing the marginal probabilities of each node being infected at a fixed time.</li><li><code>x</code>: The true configuration of the nodes at the same fixed time.</li></ul><p><strong>Returns</strong></p><ul><li><code>fp_rates</code>: Array of false positive rates corresponding to each threshold.</li><li><code>tp_rates</code>: Array of true positive rates corresponding to each threshold.</li><li><code>auc</code>: The Area Under the Curve (AUC) of the ROC curve.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/utils.jl#L59-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.bethe_lattice-Tuple{Int64, Int64}" href="#SmallCouplingDynamicCavity.bethe_lattice-Tuple{Int64, Int64}"><code>SmallCouplingDynamicCavity.bethe_lattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bethe_lattice(z::Int, tmax::Int)</code></pre><p>Generate a Bethe lattice (tree) with a specified degree and depth.</p><p><strong>Arguments</strong></p><ul><li><code>z::Int</code>: The degree of the Bethe lattice.</li><li><code>tmax::Int</code>: The maximum depth of the Bethe lattice.</li></ul><p><strong>Returns</strong></p><ul><li><code>V::Vector{Int}</code>: A list of vertices in the Bethe lattice.</li><li><code>E::Vector{Vector{Int}}</code>: A list of edges in the Bethe lattice.</li></ul><p><strong>Description</strong></p><p>This function generates a Bethe lattice (tree) with a specified degree (<code>z</code>) and maximum depth (<code>tmax</code>). The Bethe lattice is constructed by iteratively adding nodes and edges according to the specified parameters. The root node is always assigned vertex number 1, and the vertices are numbered in a depth-first manner. The edges are stored as a list of pairs of vertices, where each pair represents an edge between two vertices.</p><p>The function returns a tuple where the first element (<code>V</code>) is a list of vertices, and the second element (<code>E</code>) is a list of edges in the Bethe lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/utils.jl#L7-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.run_SCDC!-Union{Tuple{TG}, Tuple{TI}, Tuple{Array{SmallCouplingDynamicCavity.Node{TI, TG}, 1}, EpidemicModel{TI, TG}, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}" href="#SmallCouplingDynamicCavity.run_SCDC!-Union{Tuple{TG}, Tuple{TI}, Tuple{Array{SmallCouplingDynamicCavity.Node{TI, TG}, 1}, EpidemicModel{TI, TG}, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_SCDC!(
    nodes::Vector{Node{TI,TG}}, 
    model::EpidemicModel{TI,TG}, 
    γ::Float64, 
    maxiter::Vector{Int64}, 
    epsconv::Float64, 
    damp::Vector{Float64}; 
    μ_cutoff::Float64 = -Inf, 
    n_iter_nc::Int64 = 1, 
    damp_nc::Float64 = 0.0, 
    callback::Function=(x...) -&gt; nothing, 
    rng::AbstractRNG=Xoshiro(1234)) where {TI&lt;:InfectionModel,TG&lt;:Union{&lt;:AbstractGraph,Vector{&lt;:AbstractGraph}}}</code></pre><p>Run the SCDC algorithm for epidemic modeling. The algorithm resumes the message-passing iterations from the current state of the nodes.</p><p>This function performs SCDC inference on the specified epidemic model, using the provided evidence (likelihood) probability function, and other parameters such as the probability of being a patient zero, maximum number of iterations, convergence threshold, damping factor, etc. It iteratively updates cavity messages until convergence or until the maximum number of iterations is reached. It implements a dumping schedule for the damping factor, where the dumping factor is changed after a certain number of iterations, specified by the <code>maxiter</code> and <code>damp</code> arguments.</p><p><strong>Arguments</strong></p><ul><li><code>nodes::Vector{Node{TI,TG}}</code>: Vector of nodes in the epidemic model.</li><li><code>model::EpidemicModel{TI,TG}</code>: The epidemic model to be used.</li><li><code>γ::Float64</code>: A parameter for the algorithm (e.g., infection rate).</li><li><code>maxiter::Vector{Int64}</code>: Maximum number of iterations for the algorithm.</li><li><code>epsconv::Float64</code>: Convergence threshold for the algorithm.</li><li><code>damp::Vector{Float64}</code>: Damping factors for the algorithm.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>μ_cutoff::Float64</code>: Cutoff value for some parameter μ (default is -Inf).</li><li><code>n_iter_nc::Int64</code>: Number of iterations for non-converging cases (default is 1).</li><li><code>damp_nc::Float64</code>: Damping factor for non-converging cases (default is 0.0).</li><li><code>callback::Function</code>: Callback function to be called during iterations (default does nothing).</li><li><code>rng::AbstractRNG</code>: Random number generator (default is Xoshiro).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/message_passing_func.jl#L495-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.run_SCDC!-Union{Tuple{TG}, Tuple{TI}, Tuple{Array{SmallCouplingDynamicCavity.Node{TI, TG}, 1}, EpidemicModel{TI, TG}, Float64, Vector{Int64}, Float64, Vector{Float64}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:Graphs.AbstractGraph)}" href="#SmallCouplingDynamicCavity.run_SCDC!-Union{Tuple{TG}, Tuple{TI}, Tuple{Array{SmallCouplingDynamicCavity.Node{TI, TG}, 1}, EpidemicModel{TI, TG}, Float64, Vector{Int64}, Float64, Vector{Float64}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_SCDC!(nodes::Vector{Node{TI,TG}}, model::EpidemicModel{TI,TG}, γ::Float64, maxiter::Vector{Int64}, epsconv::Float64, damp::Vector{Float64}; μ_cutoff::Float64 = -Inf, n_iter_nc::Int64 = 1, damp_nc::Float64 = 0.0, callback::Function=(x...) -&gt; nothing, rng::AbstractRNG=Xoshiro(1234))</code></pre><p>Run the SCDC algorithm for epidemic modeling. The algorithm resumes the message-passing iterations from the current state of the nodes.</p><p>This function performs SCDC inference on the specified epidemic model, using the provided evidence (likelihood) probability function, and other parameters such as the probability of being a patient zero, maximum number of iterations, convergence threshold, damping factor, etc. It iteratively updates cavity messages until convergence or until the maximum number of iterations is reached. It implements a dumping schedule for the damping factor, where the dumping factor is changed after a certain number of iterations, specified by the <code>maxiter</code> and <code>damp</code> arguments.</p><p><strong>Arguments</strong></p><ul><li><code>nodes::Vector{Node{TI,TG}}</code>: Vector of nodes in the epidemic model.</li><li><code>model::EpidemicModel{TI,TG}</code>: The epidemic model to be used.</li><li><code>γ::Float64</code>: A parameter for the algorithm (e.g., infection rate).</li><li><code>maxiter::Vector{Int64}</code>: Maximum number of iterations for the algorithm.</li><li><code>epsconv::Float64</code>: Convergence threshold for the algorithm.</li><li><code>damp::Vector{Float64}</code>: Damping factors for the algorithm.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>μ_cutoff::Float64</code>: Cutoff value for some parameter μ (default is -Inf).</li><li><code>n_iter_nc::Int64</code>: Number of iterations for non-converging cases (default is 1).</li><li><code>damp_nc::Float64</code>: Damping factor for non-converging cases (default is 0.0).</li><li><code>callback::Function</code>: Callback function to be called during iterations (default does nothing).</li><li><code>rng::AbstractRNG</code>: Random number generator (default is Xoshiro).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/message_passing_func.jl#L625-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}" href="#SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Int64, Float64, Float64}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_SCDC(
    model::EpidemicModel{TI,TG},
    obsprob::Function,
    γ::Float64,
    maxiter::Int64,
    epsconv::Float64,
    damp::Float64;
    μ_cutoff::Float64 = -Inf,
    n_iter_nc::Int64 = 1,
    damp_nc::Float64 = 0.0,
    callback::Function=(x...) -&gt; nothing
    rng::AbstractRNG=Xoshiro(1234)) where {TI&lt;:InfectionModel,TG&lt;:Union{&lt;:AbstractGraph,Vector{&lt;:AbstractGraph}}}</code></pre><p>Runs the Small Coupling Dynamic Cavity (SCDC) inference algorithm.</p><p>This function performs SCDC inference on the specified epidemic model, using the provided evidence (likelihood) probability function, and other parameters such as the probability of being a patient zero, maximum number of iterations, convergence threshold, damping factor, etc. It iteratively updates cavity messages until convergence or until the maximum number of iterations is reached.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: An <a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel"><code>EpidemicModel</code></a> representing the epidemic model.</li><li><code>obsprob</code>: A function representing the evidence (likelihood) probability p(O|x) of an observation O given the planted state x.</li><li><code>γ</code>: The probability of being a patient zero.</li><li><code>maxiter</code>: The maximum number of iterations.</li><li><code>epsconv</code>: The convergence threshold of the algorithm.</li><li><code>damp</code>: The damping factor of the algorithm.</li><li><code>μ_cutoff</code>: (Optional) Lower cut-off for the values of μ.</li><li><code>n_iter_nc</code>: (Optional) Number of iterations for non-converged messages. The messages are averaged over this number of iterations.</li><li><code>damp_nc</code>: (Optional) Damping factor for non-converged messages.</li><li><code>callback</code>: (Optional) A callback function to monitor the progress of the algorithm.</li><li><code>rng</code>: (Optional) Random number generator.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes</code>: An array of <a href="functions.html#SmallCouplingDynamicCavity.Node"><code>Node</code></a> objects representing the updated node states after inference.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/message_passing_func.jl#L208-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Vector{Int64}, Float64, Vector{Float64}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:Graphs.AbstractGraph)}" href="#SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Vector{Int64}, Float64, Vector{Float64}}} where {TI&lt;:SmallCouplingDynamicCavity.InfectionModel, TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:Graphs.AbstractGraph)}"><code>SmallCouplingDynamicCavity.run_SCDC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_SCDC(
    model::EpidemicModel{TI,TG},
    obsprob::Function,
    γ::Float64,
    maxiter::Vector{Int64},
    epsconv::Float64,
    damp::Vector{Float64};
    μ_cutoff::Float64 = -Inf,
    n_iter_nc::Int64 = 1,
    damp_nc::Float64 = 0.0,
    callback::Function=(x...) -&gt; nothing,
    rng::AbstractRNG=Xoshiro(1234)) where {TI&lt;:InfectionModel,TG&lt;:Union{&lt;:AbstractGraph,Vector{&lt;:AbstractGraph}}}</code></pre><p>Runs the Small Coupling Dynamic Cavity (SCDC) inference algorithm.</p><p>This function performs SCDC inference on the specified epidemic model, using the provided evidence (likelihood) probability function, and other parameters such as the probability of being a patient zero, maximum number of iterations, convergence threshold, damping factor, etc. It iteratively updates cavity messages until convergence or until the maximum number of iterations is reached. It implements a dumping schedule for the damping factor, where the dumping factor is changed after a certain number of iterations, specified by the <code>maxiter</code> and <code>damp</code> arguments.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: An <a href="functions.html#SmallCouplingDynamicCavity.EpidemicModel"><code>EpidemicModel</code></a> representing the epidemic model.</li><li><code>obsprob</code>: A function representing the evidence (likelihood) probability p(O|x) of an observation O given the planted state x.</li><li><code>γ</code>: The probability of being a patient zero.</li><li><code>maxiter</code>: Vector of maximum number of iterations for each damping factor. </li><li><code>epsconv</code>: The convergence threshold of the algorithm.</li><li><code>damp</code>: Vector of damping factors used in the damping schedule.</li><li><code>μ_cutoff</code>: (Optional) Lower cut-off for the values of μ.</li><li><code>n_iter_nc</code>: (Optional) Number of iterations for non-converged messages. The messages are averaged over this number of iterations.</li><li><code>damp_nc</code>: (Optional) Damping factor for non-converged messages.</li><li><code>callback</code>: (Optional) A callback function to monitor the progress of the algorithm.</li><li><code>rng</code>: (Optional) Random number generator.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes</code>: An array of <a href="functions.html#SmallCouplingDynamicCavity.Node"><code>Node</code></a> objects representing the updated node states after inference.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/message_passing_func.jl#L344-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.SI" href="#SmallCouplingDynamicCavity.SI"><code>SmallCouplingDynamicCavity.SI</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SI &lt;: InfectionModel
    εᵢᵗ::Array{Float64, 2} # Autoinfection probabilities
end</code></pre><p>The <code>SI</code> struct represents the SI (Susceptible-Infected) infection model.</p><p><strong>Fields</strong></p><ul><li><code>εᵢᵗ</code>: An NVxT array representing the self-infection probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element εᵢᵗ[i, t] denotes the probability of node i infecting itself at time t.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SI.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SI, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)" href="#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SI, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_epidemics(
    model::EpidemicModel{SI,TG};
    patient_zero::Union{Vector{Int},Nothing}=nothing,
    γ::Union{Float64,Nothing}=nothing) where {TG&lt;:Union{&lt;:AbstractGraph,Vector{&lt;:AbstractGraph}}}</code></pre><p>Simulates an epidemic outbreak using the SI (Susceptible-Infectious) model.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: The SI epidemic model, encapsulating information about the infection dynamics, contact graph, and other parameters.</li><li><code>patient_zero</code>: (Optional) A vector specifying the indices of initial infected individuals. If not provided (default <code>nothing</code>), patient zero is selected randomly based on the probability <code>γ</code>.</li><li><code>γ</code>: (Optional) The probability of being a patient zero. If <code>patient_zero</code> is not specified and <code>γ</code> is provided, patient zero is chosen randomly with probability <code>γ</code>. If both <code>patient_zero</code> and <code>γ</code> are not provided (default <code>nothing</code>), patient zero is selected randomly with equal probability for each individual.</li><li><code>rng</code>: (Optional) A random number generator. Default is <code>Xoshiro(1234)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix representing the epidemic outbreak configuration over time. Each row corresponds to a node, and each column represents a time step. The values in the matrix indicate the state of each node at each time step: 0.0 for Susceptible (S) and 1.0 for Infected (I).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SI.jl#L124-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.SIR" href="#SmallCouplingDynamicCavity.SIR"><code>SmallCouplingDynamicCavity.SIR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SIR &lt;: InfectionModel
    εᵢᵗ::Array{Float64, 2} # Autoinfection probabilities
    rᵢᵗ::Array{Float64, 2} # Recovery probabilities
end</code></pre><p>The <code>SIR</code> struct represents the SIR (Susceptible-Infected-Recovered) infection model.</p><p><strong>Fields</strong></p><ul><li><code>εᵢᵗ</code>: An NVxT array representing the self-infection probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element εᵢᵗ[i, t] denotes the probability of node i infecting itself at time t.</li><li><code>rᵢᵗ</code>: An NVxT array representing the recovery probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element rᵢᵗ[i, t] denotes the probability of node i recovering from infection at time t.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SIR.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIR, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)" href="#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIR, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_epidemics(
    model::EpidemicModel{SIR,TG};
    patient_zero::Union{Vector{Int},Nothing}=nothing,
    γ::Union{Float64,Nothing}=nothing) where {TG&lt;:Union{&lt;:AbstractGraph,Vector{&lt;:AbstractGraph}}}</code></pre><p>Simulates an epidemic outbreak using the SIR (Susceptible-Infectious-Recovered) model.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: The SIR epidemic model, encapsulating information about the infection dynamics, contact graph, and other parameters.</li><li><code>patient_zero</code>: (Optional) A vector specifying the indices of initial infected individuals. If not provided (default <code>nothing</code>), patient zero is selected randomly based on the probability <code>γ</code>.</li><li><code>γ</code>: (Optional) The probability of being a patient zero. If <code>patient_zero</code> is not specified and <code>γ</code> is provided, patient zero is chosen randomly with probability <code>γ</code>. If both <code>patient_zero</code> and <code>γ</code> are not provided (default <code>nothing</code>), patient zero is selected randomly with equal probability for each individual.</li><li><code>rng</code>: (Optional) A random number generator. Default is <code>Xoshiro(1234)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix representing the epidemic outbreak configuration over time. Each row corresponds to a node, and each column represents a time step. The values in the matrix indicate the state of each node at each time step: 0.0 for Susceptible (S), 1.0 for Infected (I), and 2.0 for Recovered (R).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SIR.jl#L142-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.SIS" href="#SmallCouplingDynamicCavity.SIS"><code>SmallCouplingDynamicCavity.SIS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SIS &lt;: InfectionModel
    εᵢᵗ::Array{Float64, 2} # Autoinfection probabilities
    rᵢᵗ::Array{Float64, 2} # Recovery probabilities
end</code></pre><p>The <code>SIS</code> struct represents the SIS (Susceptible-Infected-Susceptible) infection model.</p><p><strong>Fields</strong></p><ul><li><code>εᵢᵗ</code>: An NVxT array representing the self-infection probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element εᵢᵗ[i, t] denotes the probability of node i infecting itself at time t.</li><li><code>rᵢᵗ</code>: An NVxT array representing the recovery probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element rᵢᵗ[i, t] denotes the probability of node i recovering from infection at time t.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SIS.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIS, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)" href="#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIS, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_epidemics(
    model::EpidemicModel{SIS,TG};
    patient_zero::Union{Vector{Int},Nothing}=nothing,
    γ::Union{Float64,Nothing}=nothing) where {TG&lt;:Union{&lt;:AbstractGraph,Vector{&lt;:AbstractGraph}}}</code></pre><p>Simulates an epidemic outbreak using the SIS (Susceptible-Infectious-Susceptible) model.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: The SIS epidemic model, encapsulating information about the infection dynamics, contact graph, and other parameters.</li><li><code>patient_zero</code>: (Optional) A vector specifying the indices of initial infected individuals. If not provided (default <code>nothing</code>), patient zero is selected randomly based on the probability <code>γ</code>.</li><li><code>γ</code>: (Optional) The probability of being a patient zero. If <code>patient_zero</code> is not specified and <code>γ</code> is provided, patient zero is chosen randomly with probability <code>γ</code>. If both <code>patient_zero</code> and <code>γ</code> are not provided (default <code>nothing</code>), patient zero is selected randomly with equal probability for each individual.</li><li><code>rng</code>: (Optional) A random number generator. Default is <code>Xoshiro(1234)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix representing the epidemic outbreak configuration over time. Each row corresponds to a node, and each column represents a time step. The values in the matrix indicate the state of each node at each time step: 0.0 for Susceptible (S) and 1.0 for Infected (I).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SIS.jl#L135-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.SIRS" href="#SmallCouplingDynamicCavity.SIRS"><code>SmallCouplingDynamicCavity.SIRS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SIRS &lt;: InfectionModel
    εᵢᵗ::Array{Float64, 2} # Autoinfection probabilities
    rᵢᵗ::Array{Float64, 2} # Recovery probabilities
    σᵢᵗ::Array{Float64, 2} # Loss of immunity probabilities
end</code></pre><p>The <code>SIRS</code> struct represents the SIRS (Susceptible-Infected-Recovered-Susceptible) infection model.</p><p><strong>Fields</strong></p><ul><li><code>εᵢᵗ</code>: An NVxT array representing the self-infection probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element εᵢᵗ[i, t] denotes the probability of node i infecting itself at time t.</li><li><code>rᵢᵗ</code>: An NVxT array representing the recovery probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element rᵢᵗ[i, t] denotes the probability of node i recovering from infection at time t.</li><li><code>σᵢᵗ</code>: An NVxT array representing the loss of immunity probabilities over time, where NV is the number of nodes and T is the number of time-steps. Each element σᵢᵗ[i, t] denotes the probability of node i losing immunity and becoming susceptible again at time t.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SIRS.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIRS, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)" href="#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIRS, TG}}, Tuple{TG}} where TG&lt;:(Union{Vector{&lt;:Graphs.AbstractGraph}, var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Graphs.AbstractGraph)"><code>SmallCouplingDynamicCavity.sim_epidemics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_epidemics(
    model::EpidemicModel{SIRS,TG};
    patient_zero::Union{Vector{Int},Nothing}=nothing,
    γ::Union{Float64,Nothing}=nothing) where {TG&lt;:Union{&lt;:AbstractGraph,Vector{&lt;:AbstractGraph}}}</code></pre><p>Simulates an epidemic outbreak using the SIRS (Susceptible-Infectious-Recovered-Susceptible) model.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: The SIRS epidemic model, encapsulating information about the infection dynamics, contact graph, and other parameters.</li><li><code>patient_zero</code>: (Optional) A vector specifying the indices of initial infected individuals. If not provided (default <code>nothing</code>), patient zero is selected randomly based on the probability <code>γ</code>.</li><li><code>γ</code>: (Optional) The probability of being a patient zero. If <code>patient_zero</code> is not specified and <code>γ</code> is provided, patient zero is chosen randomly with probability <code>γ</code>. If both <code>patient_zero</code> and <code>γ</code> are not provided (default <code>nothing</code>), patient zero is selected randomly with equal probability for each individual.</li><li><code>rng</code>: (Optional) A random number generator. Default is <code>Xoshiro(1234)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix representing the epidemic outbreak configuration over time. Each row corresponds to a node, and each column represents a time step. The values in the matrix indicate the state of each node at each time step: 0.0 for Susceptible (S), 1.0 for Infected (I), and 2.0 for Recovered (R).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mattiatarabolo/SmallCouplingDynamicCavity.jl/blob/9119741287a761e1e86c93282a4cf81d3de6ff44/src/models/SIRS.jl#L151-L167">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="guide.html">« Guide</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 13 November 2024 09:32">Wednesday 13 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
