var documenterSearchIndex = {"docs":
[{"location":"functions.html","page":"Functions","title":"Functions","text":"CurrentModule = SmallCouplingDynamicCavity","category":"page"},{"location":"functions.html#The-MyAwesomePackage-Module","page":"Functions","title":"The MyAwesomePackage Module","text":"","category":"section"},{"location":"functions.html","page":"Functions","title":"Functions","text":"SmallCouplingDynamicCavity","category":"page"},{"location":"functions.html#SmallCouplingDynamicCavity.SmallCouplingDynamicCavity","page":"Functions","title":"SmallCouplingDynamicCavity.SmallCouplingDynamicCavity","text":"Module for \"SmallCouplingDynamicCavity.jl\" – A package for a Small Coupling expansion of the Dynamic Cavity method for epidemic inference.\n\n\n\n\n\n","category":"module"},{"location":"functions.html#Module-Index","page":"Functions","title":"Module Index","text":"","category":"section"},{"location":"functions.html","page":"Functions","title":"Functions","text":"Modules = [SmallCouplingDynamicCavity]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"functions.html#Detailed-API","page":"Functions","title":"Detailed API","text":"","category":"section"},{"location":"functions.html","page":"Functions","title":"Functions","text":"Modules = [SmallCouplingDynamicCavity]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"functions.html#SmallCouplingDynamicCavity.SI-Tuple{Union{Float64, Matrix{Float64}}, Int64, Int64}","page":"Functions","title":"SmallCouplingDynamicCavity.SI","text":"SI(\n    εᵢᵗ::Union{Float64,Array{Float64,2}},\n    NV::Int,\n    T::Int)\n\nDefines the SIS infection model.\n\nArguments\n\nεᵢᵗ: Self-infection probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nNV: Number of nodes of the contact graph.\nT: Number of time-steps.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.SIR-Tuple{Union{Float64, Matrix{Float64}}, Union{Float64, Matrix{Float64}}, Int64, Int64}","page":"Functions","title":"SmallCouplingDynamicCavity.SIR","text":"SIR(\n    εᵢᵗ::Union{Float64,Array{Float64,2}},\n    rᵢᵗ::Union{Float64,Array{Float64,2}},\n    NV::Int,\n    T::Int)\n\nDefines the SIS infection model.\n\nArguments\n\nεᵢᵗ: Self-infection probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nrᵢᵗ: Recovery probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nNV: Number of nodes of the contact graph.\nT: Number of time-steps.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.SIRS-Tuple{Union{Float64, Matrix{Float64}}, Union{Float64, Matrix{Float64}}, Union{Float64, Matrix{Float64}}, Int64, Int64}","page":"Functions","title":"SmallCouplingDynamicCavity.SIRS","text":"SIRS(\n    εᵢᵗ::Union{Float64,Array{Float64,2}},\n    rᵢᵗ::Union{Float64,Array{Float64,2}},\n    σᵢᵗ::Union{Float64,Array{Float64,2}},\n    NV::Int,\n    T::Int)\n\nDefines the SIS infection model.\n\nArguments\n\nεᵢᵗ: Self-infection probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nrᵢᵗ: Recovery probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nσᵢᵗ: Loss of immunity probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nNV: Number of nodes of the contact graph.\nT: Number of time-steps.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.SIS-Tuple{Union{Float64, Matrix{Float64}}, Union{Float64, Matrix{Float64}}, Int64, Int64}","page":"Functions","title":"SmallCouplingDynamicCavity.SIS","text":"SIS(\n    εᵢᵗ::Union{Float64,Array{Float64,2}},\n    rᵢᵗ::Union{Float64,Array{Float64,2}},\n    NV::Int,\n    T::Int)\n\nDefines the SIS infection model.\n\nArguments\n\nεᵢᵗ: Self-infection probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nrᵢᵗ: Recovery probability. Can be either a Float64 (constant over all nodes and times) or a NVxT matrix.\nNV: Number of nodes of the contact graph.\nT: Number of time-steps.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.run_SCDC-Union{Tuple{TG}, Tuple{TI}, Tuple{EpidemicModel{TI, TG}, Function, Float64, Int64, Float64, Float64}} where {TI<:SmallCouplingDynamicCavity.InfectionModel, TG<:(Union{Vector{<:Graphs.AbstractGraph}, var\"#s7\"} where var\"#s7\"<:Graphs.AbstractGraph)}","page":"Functions","title":"SmallCouplingDynamicCavity.run_SCDC","text":"run_SCDC(\n    model::EpidemicModel{TI,TG},\n    obsprob::Function,\n    γ::Float64,\n    maxiter::Int64,\n    epsconv::Float64,\n    damp::Float64;\n    μ_cutoff::Float64 = -Inf,\n    callback::Function=(x...) -> nothing) where {TI<:InfectionModel,TG<:Union{<:AbstractGraph,Vector{<:AbstractGraph}}}\n\nRuns the SCDC inference.\n\nArguments\n\nmodel: Epidemic model.\nobsprob: Evidence (likelihood) probability p(O|x) of an obseravtion O given the planted state x.\nγ: Probability of being a patient zero.\nmaxiter: Maximum number of iterations.\nepsconv: Convergence threshold of the algorithm.\ndamp: Damping factor of the algorithm.\nμ_cutoff: Lower cut-off for the values of μ.\ncallback: Callback function.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SI, TG}}, Tuple{TG}} where TG<:(Union{Vector{<:Graphs.AbstractGraph}, var\"#s12\"} where var\"#s12\"<:Graphs.AbstractGraph)","page":"Functions","title":"SmallCouplingDynamicCavity.sim_epidemics","text":"sim_epidemics(\n    model::EpidemicModel{SI,TG};\n    patient_zero::Union{Vector{Int},Nothing}=nothing,\n    γ::Union{Float64,Nothing}=nothing) where {TG<:Union{<:AbstractGraph,Vector{<:AbstractGraph}}}\n\nSimulates the epidemic outbreak given a SI model. \n\nArguments\n\nmodel: The SI epidemic model.\npatient_zero: Vector of patients zero. Default is \"nothing\", meaning that the patients zero are chosen at random with probability γ.\nγ: Probability of being a patient zero. Default is \"nothing\", meaning that it is fixed to0 1/NV, where NV is the number of nodes of the contact graph.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIR, TG}}, Tuple{TG}} where TG<:(Union{Vector{<:Graphs.AbstractGraph}, var\"#s12\"} where var\"#s12\"<:Graphs.AbstractGraph)","page":"Functions","title":"SmallCouplingDynamicCavity.sim_epidemics","text":"sim_epidemics(\n    model::EpidemicModel{SIR,TG};\n    patient_zero::Union{Vector{Int},Nothing}=nothing,\n    γ::Union{Float64,Nothing}=nothing) where {TG<:Union{<:AbstractGraph,Vector{<:AbstractGraph}}}\n\nSimulates the epidemic outbreak given a SIR model. \n\nArguments\n\nmodel: The SIR epidemic model.\npatient_zero: Vector of patients zero. Default is \"nothing\", meaning that the patients zero are chosen at random with probability γ.\nγ: Probability of being a patient zero. Default is \"nothing\", meaning that it is fixed to0 1/NV, where NV is the number of nodes of the contact graph.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIRS, TG}}, Tuple{TG}} where TG<:(Union{Vector{<:Graphs.AbstractGraph}, var\"#s12\"} where var\"#s12\"<:Graphs.AbstractGraph)","page":"Functions","title":"SmallCouplingDynamicCavity.sim_epidemics","text":"sim_epidemics(\n    model::EpidemicModel{SIRS,TG};\n    patient_zero::Union{Vector{Int},Nothing}=nothing,\n    γ::Union{Float64,Nothing}=nothing) where {TG<:Union{<:AbstractGraph,Vector{<:AbstractGraph}}}\n\nSimulates the epidemic outbreak given a SIRS model. \n\nArguments\n\nmodel: The SIRS epidemic model.\npatient_zero: Vector of patients zero. Default is \"nothing\", meaning that the patients zero are chosen at random with probability γ.\nγ: Probability of being a patient zero. Default is \"nothing\", meaning that it is fixed to0 1/NV, where NV is the number of nodes of the contact graph.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SmallCouplingDynamicCavity.sim_epidemics-Union{Tuple{EpidemicModel{SIS, TG}}, Tuple{TG}} where TG<:(Union{Vector{<:Graphs.AbstractGraph}, var\"#s12\"} where var\"#s12\"<:Graphs.AbstractGraph)","page":"Functions","title":"SmallCouplingDynamicCavity.sim_epidemics","text":"sim_epidemics(\n    model::EpidemicModel{SIS,TG};\n    patient_zero::Union{Vector{Int},Nothing}=nothing,\n    γ::Union{Float64,Nothing}=nothing) where {TG<:Union{<:AbstractGraph,Vector{<:AbstractGraph}}}\n\nSimulates the epidemic outbreak given a SIS model. \n\nArguments\n\nmodel: The SIS epidemic model.\npatient_zero: Vector of patients zero. Default is \"nothing\", meaning that the patients zero are chosen at random with probability γ.\nγ: Probability of being a patient zero. Default is \"nothing\", meaning that it is fixed to0 1/NV, where NV is the number of nodes of the contact graph.\n\n\n\n\n\n","category":"method"},{"location":"guide.html#Basic-use","page":"Guide","title":"Basic use","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Define an infection model through the available structures.","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"# SI model with 0.0 self-infection rate, 4 individuals and 5 epidemic timesteps\njulia> infection_model = SI(0.0, 4, 5)\nSI([0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"Define an epidemic model","category":"page"},{"location":"guide.html","page":"Guide","title":"Guide","text":"# SI epidemic model on a graph G with infection probability encoded by the matrix λ \njulia> model = EpidemicModel(infection_model, G, 5, log.(1 .- λ))","category":"page"},{"location":"guide.html#Sampling","page":"Guide","title":"Sampling","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"# Sample the epidemic cascade specifying the patient zero as individual 1\njulia> config = sim_epidemics(model, patient_zero=[1])\n4×6 Matrix{Float64}:\n1.0  1.0  1.0  1.0  1.0  1.0\n0.0  1.0  1.0  1.0  1.0  1.0\n0.0  1.0  1.0  1.0  1.0  1.0\n0.0  0.0  0.0  1.0  1.0  1.0","category":"page"},{"location":"guide.html#Inference","page":"Guide","title":"Inference","text":"","category":"section"},{"location":"guide.html","page":"Guide","title":"Guide","text":"# Insert the observations as a matrix (-1.0 = unobserved, 0.0 = observed S, 1.0 = observed I)\njulia> model.obsmat .= [-1.0 -1.0 1.0 -1.0 -1.0 -1.0; 0.0 -1.0 -1.0 -1.0 1.0 -1.0; -1.0 -1.0 -1.0 -1.0 -1.0 -1.0;  -1.0 -1.0 -1.0 -1.0 -1.0 1.0]\n4×6 Matrix{Float64}:\n-1.0  -1.0   1.0  -1.0  -1.0  -1.0\n 0.0  -1.0  -1.0  -1.0   1.0  -1.0\n-1.0  -1.0  -1.0  -1.0  -1.0  -1.0\n-1.0  -1.0  -1.0  -1.0  -1.0   1.0\n\n# Run the inference algorithm with maximum 10 iterations, a convergence threshold of 0.1, and a damping factor of 0.0. The prior probability of being infected at time 0 is 1/4, and the observation probability obsprob is user-specified\njulia> nodes = run_SCDC(model, obsprob, 1/4, 10, 0.1, 0.0)\nConverged after 4 iterations\n4-element Vector{SmallCouplingDynamicCavity.Node{SI}}","category":"page"},{"location":"index.html#SmallCouplingDynamicCavity.jl","page":"Home","title":"SmallCouplingDynamicCavity.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Documentation for SmallCouplingDynamicCavity.jl. The GitHub repository can be found at SmallCouplingDynamicCavity.jl.git.","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The purpose of SmallCouplingDynamicCavity.jl is to provide a general and computationally efficient solution for Bayesian epidemic inference and risk assessment. The package offers an efficient structure implementation for the most used epidemic models, such as Susceptible-Infected (SI), Susceptible-Infected-Recovered (SIR), Susceptible-Infected-Susceptible (SIS) and Susceptible-Infected-Recovered-Susceptible (SIRS).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For all these models, the package provides:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"a simulation tool, which allows to sample an epidemic outbreak with specified parameters\na statistical inference tool, which allows to obtain fully bayesian estimates of the epidemic uotbreak","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pkg> add SmallCouplingDynamicCavity","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"SmallCouplingDynamicCavity\")","category":"page"},{"location":"index.html#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]","category":"page"}]
}
